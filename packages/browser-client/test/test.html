<script>
    !function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e || self).jsreport = t() }(this, function () { function e() { return e = Object.assign || function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, e.apply(this, arguments) } var t = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, n = function (e) { var n = { exports: {} }; return function (e, n) { !function () { function n(e, t, n) { var r = new XMLHttpRequest; r.open("GET", e), r.responseType = "blob", r.onload = function () { a(r.response, t, n) }, r.onerror = function () { console.error("could not download file") }, r.send() } function r(e) { var t = new XMLHttpRequest; t.open("HEAD", e, !1); try { t.send() } catch (e) { } return 200 <= t.status && 299 >= t.status } function o(e) { try { e.dispatchEvent(new MouseEvent("click")) } catch (n) { var t = document.createEvent("MouseEvents"); t.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), e.dispatchEvent(t) } } var i = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof t && t.global === t ? t : void 0, s = i.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), a = i.saveAs || ("object" != typeof window || window !== i ? function () { } : "download" in HTMLAnchorElement.prototype && !s ? function (e, t, s) { var a = i.URL || i.webkitURL, c = document.createElement("a"); c.download = t = t || e.name || "download", c.rel = "noopener", "string" == typeof e ? (c.href = e, c.origin === location.origin ? o(c) : r(c.href) ? n(e, t, s) : o(c, c.target = "_blank")) : (c.href = a.createObjectURL(e), setTimeout(function () { a.revokeObjectURL(c.href) }, 4e4), setTimeout(function () { o(c) }, 0)) } : "msSaveOrOpenBlob" in navigator ? function (e, t, i) { if (t = t || e.name || "download", "string" != typeof e) navigator.msSaveOrOpenBlob(function (e, t) { return void 0 === t ? t = { autoBom: !1 } : "object" != typeof t && (console.warn("Deprecated: Expected third argument to be a object"), t = { autoBom: !t }), t.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type) ? new Blob(["\ufeff", e], { type: e.type }) : e }(e, i), t); else if (r(e)) n(e, t, i); else { var s = document.createElement("a"); s.href = e, s.target = "_blank", setTimeout(function () { o(s) }) } } : function (e, t, r, o) { if ((o = o || open("", "_blank")) && (o.document.title = o.document.body.innerText = "downloading..."), "string" == typeof e) return n(e, t, r); var a = "application/octet-stream" === e.type, c = /constructor/i.test(i.HTMLElement) || i.safari, u = /CriOS\/[\d]+/.test(navigator.userAgent); if ((u || a && c || s) && "undefined" != typeof FileReader) { var l = new FileReader; l.onloadend = function () { var e = l.result; e = u ? e : e.replace(/^data:[^;]*;/, "data:attachment/file;"), o ? o.location.href = e : location = e, o = null }, l.readAsDataURL(e) } else { var f = i.URL || i.webkitURL, d = f.createObjectURL(e); o ? o.location = d : location.href = d, o = null, setTimeout(function () { f.revokeObjectURL(d) }, 4e4) } }); i.saveAs = a.saveAs = a, e.exports = a }() }(n), n.exports }(); function r(e, t) { try { var n = e() } catch (e) { return t(e) } return n && n.then ? n.then(void 0, t) : n } var o =/*#__PURE__*/function () { function e(e) { this._response = e } var t, r = e.prototype; return r.toString = function () { try { return Promise.resolve(this.response.blob()).then(function (e) { return e.text() }) } catch (e) { return Promise.reject(e) } }, r.download = function (e) { try { return Promise.resolve(this.response.blob()).then(function (t) { n.saveAs(t, e) }) } catch (e) { return Promise.reject(e) } }, r.toBlob = function () { try { return Promise.resolve(this.response.blob()) } catch (e) { return Promise.reject(e) } }, r.toDataURI = function () { try { var e = new FileReader; return Promise.resolve(this.response.blob()).then(function (t) { return new Promise(function (n) { e.onload = function (t) { n(e.result) }, e.readAsDataURL(t) }) }) } catch (e) { return Promise.reject(e) } }, r.openInWindow = function (e) { var t = void 0 === e ? {} : e, n = t.cleanInterval, r = void 0 === n ? 5e3 : n, o = t.windowName, i = t.windowFeatures; try { return Promise.resolve(this.response.blob()).then(function (e) { var t = URL.createObjectURL(e, o, i), n = window.open(t), s = setInterval(function () { n.closed && (URL.revokeObjectURL(t), clearInterval(s)) }, r); return n }) } catch (e) { return Promise.reject(e) } }, r.toObjectURL = function () { try { return Promise.resolve(this.response.blob()).then(URL.createObjectURL) } catch (e) { return Promise.reject(e) } }, (t = [{ key: "response", get: function () { return this._response } }]) && function (e, t) { for (var n = 0; n < t.length; n++) { var r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } }(e.prototype, t), e }(); return new (/*#__PURE__*/function () { function t() { this.headers = {} } var n = t.prototype; return n.render = function (t) { try { var n, i = this, s = function (t) { function i(e) { return new o(n) } var s = function () { if (!n.ok) { var t = function () { var e = new Error(o.message); throw Object.assign(e, { status: n.status, statusText: n.statusText, error: o }), e }, o = { message: "Error rendering in jsreport server. status text: " + n.statusText + ", status code: " + n.status }, i = r(function () { return Promise.resolve(n.blob()).then(function (t) { return Promise.resolve(t.text()).then(function (t) { var n = JSON.parse(t); o = e({}, n, { message: o.message + ", details: " + n.message }) }) }) }, function () { }); return i && i.then ? i.then(t) : t() } }(); return s && s.then ? s.then(i) : i() }; if (!i.serverUrl) throw new Error("The script was not linked from jsreport. You need to fill jsreport.serverUrl property with valid url to jsreport server."); var a = r(function () { return Promise.resolve(fetch(i.serverUrl + "/api/report", { headers: e({ "Content-Type": "application/json" }, i.headers), body: JSON.stringify(t), method: "POST" })).then(function (e) { n = e }) }, function () { throw new Error("Failed to connect to jsreport server.") }); return Promise.resolve(a && a.then ? a.then(s) : s()) } catch (e) { return Promise.reject(e) } }, n.createClient = function () { return new t }, t }()) });
//# sourceMappingURL=index.umd.js.map

</script>

<div style='height: 500px; background-color: red'>
    <iframe frameborder='0' style='width:100%;height:100%;z-index:50' id='frame'></iframe>
</div>

<script>
    jsreport.serverUrl = 'http://localhost:5488'

    async function test() {
        const r = await jsreport.render({
            template: {
                recipe: 'html',
                engine: 'none',
                content: '<h1>Hello world</h1>'
            }
        })
        const str = await r.toObjectURL()
        const frame = document.getElementById('frame')
        frame.src = str
    }
    test().catch(console.error)
</script>